// @ts-check

import { join } from "https://deno.land/std@0.119.0/path/mod.ts";
import { mapIndex } from "./src/mapDiffOffsetsIndex.js";

/**
 * @typedef DenoCoverageData
 * @property {string} [url]
 * @property {DenoCoverageFunctionData[]} [functions]
 */

/**
 * @typedef DenoCoverageFunctionData
 * @property {string} [functionName]
 * @property {boolean} [isBlockCoverage]
 * @property {DenoCoverageRangeData[]} [ranges]
 */

/**
 * @typedef DenoCoverageRangeData
 * @property {number} [startOffset]
 * @property {number} [endOffset]
 * @property {number} [count]
 */

/**
 * @param {string} path
 */
async function assertIsDir(path) {
  const fileInfo = await Deno.stat(path);
  if (!fileInfo.isDirectory) {
    throw new Error(`${path} is not a directory.`);
  }
}

/**
 * @param {string} coverageMapPath The absolute path to the directory containing the coverage map data generated fake-imports.
 * @param {string} denoCoveragePath The absolute path to the directory containing the coverage data generated by Deno.
 */
export async function applyCoverage(coverageMapPath, denoCoveragePath) {
  await assertIsDir(coverageMapPath);
  await assertIsDir(denoCoveragePath);

  // Collect all the entries in the coverage map directory.
  /** @type {Map<string, import("./mod.js").CoverageMapEntry>} */
  const collectedMapEntries = new Map();
  const covMapPromises = [];
  for await (const file of Deno.readDir(coverageMapPath)) {
    const filePath = join(coverageMapPath, file.name);
    const promise = (async () => {
      const fileContent = await Deno.readTextFile(filePath);
      const fileJson = JSON.parse(fileContent);
      const castFileJson =
        /** @type {import("./mod.js").CoverageMapEntry} */ (fileJson);
      collectedMapEntries.set(castFileJson.replacedUrl, castFileJson);
    })();
    covMapPromises.push(promise);
  }
  await Promise.all(covMapPromises);

  // Apply the collected entries to the deno coverage directory.
  const denoCoveragePromises = [];
  for await (const file of Deno.readDir(denoCoveragePath)) {
    const filePath = join(denoCoveragePath, file.name);
    const promise = (async () => {
      const oldContent = await Deno.readTextFile(filePath);
      const coverageJson =
        /** @type {DenoCoverageData} */ (JSON.parse(oldContent));
      if (!coverageJson.url) return;

      const mappedEntry = collectedMapEntries.get(coverageJson.url);
      if (!mappedEntry) return;

      coverageJson.url = mappedEntry.originalUrl;

      if (coverageJson.functions) {
        for (const fn of coverageJson.functions) {
          if (fn.ranges) {
            for (const range of fn.ranges) {
              if (range.startOffset != undefined) {
                range.startOffset = mapIndex(
                  range.startOffset,
                  mappedEntry.diffOffsets,
                );
              }
              if (range.endOffset != undefined) {
                range.endOffset = mapIndex(
                  range.endOffset,
                  mappedEntry.diffOffsets,
                );
              }
            }
          }
        }
      }

      const newContent = JSON.stringify(coverageJson, null, 2);
      await Deno.writeTextFile(filePath, newContent);
    })();
    denoCoveragePromises.push(promise);
  }
  await Promise.all(denoCoveragePromises);
}

if (import.meta.main) {
  const coverageMapPath = join(Deno.cwd(), Deno.args[0]);
  const denoCoveragePath = join(Deno.cwd(), Deno.args[1]);
  applyCoverage(coverageMapPath, denoCoveragePath);
}
